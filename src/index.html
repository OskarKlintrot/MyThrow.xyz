<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, shrink-to-fit=no"
    />

    <title>My Throw</title>

    <link rel="canonical" href="https://mythrow.xyz/" />

    <meta name="application-name" content="My Throw" />
    <meta name="msapplication-tooltip" content="My Throw" />
    <meta name="msapplication-starturl" content="/" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/favicon/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/favicon/favicon-16x16.png"
    />
    <link rel="manifest" href="/site.webmanifest" />

    <meta name="color-scheme" content="light dark" />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: light)"
      content="#f2f2f2"
    />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: dark)"
      content="#24292e"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css"
    />
  </head>

  <body>
    <button
      type="button"
      id="about-dialog-trigger"
      class="top-right-corner circle"
    >
      ?
    </button>
    <dialog id="about-dialog">
      <header>About</header>
      <article>
        <p>
          This site is intended to be a quick and easy way to measure distance
          for disc golf field work.
        </p>
        <p>
          MyThrow.xyz uses your GPS to get the distance as accurate as possible.
          It might take 30-60 seconds (or more) for the accuracy to go down to
          usable levels. This is due to your phone looking for GPS satellites
          and is nothing that can be fixed by a website. Buildings, clothing and
          even a cloudy sky can all impact the accuracy of the GPS signal.
        </p>
        <p>
          Press "set start" to tell the app where you're throwing from. Go to
          your disc and check the distance. If you press "save throw" your
          current position will be saved and an average of all throws will be
          calculated. To start over just press "reset all" or close this tab in
          your browser. You can press "set start" multiple times, each time the
          starting position will reset to your current location and all
          distances will be recalculated.
        </p>
        <p>
          Source code is available at
          <a href="https://github.com/OskarKlintrot/MyThrow.xyz">github.com</a>.
        </p>
      </article>
      <button type="button" autofocus>close</button>
    </dialog>
    <div id="app">
      <header>
        <h1>MyThrow.xyz</h1>
      </header>
      <main>
        <p>Distance: <span id="distance">–</span></p>
        <p><small id="status"></small></p>
        <div id="throws-statistics"></div>
      </main>
      <footer>
        <button type="button" id="unit-btn">...</button>
        <button type="button" id="start-btn">set start</button>
        <button type="button" id="save-btn">save throw</button>
        <button type="button" id="reset-all-btn">reset all</button>
        <button type="button" id="clear-throws-btn">clear throws</button>
      </footer>
    </div>

    <style type="text/css">
      html {
        font-size: 1.3em;
      }

      body {
        line-height: 1.3;
        margin: 0 auto 0 auto; /* prevents scrollbars */
      }

      h1 {
        margin-bottom: 0;
      }

      p:has(span#distance) {
        font-size: 1.5rem;
      }

      .top-right-corner {
        position: absolute;
        margin: 0;
        padding: 0;
        top: 0.8rem;
        right: 0.8rem;
      }

      .circle {
        background: var(--background);
        border-radius: 50%;
        width: 2rem;
        height: 2rem;
        text-align: center;
      }

      #about-dialog {
        padding: 10px 10px;
      }

      #about-dialog > article {
        padding: 0 10px 0 10px;
        margin-bottom: 10px;
        max-height: 60vh;
        overflow: auto;
      }

      #about-dialog p {
        font-size: 1rem;
      }

      #about-dialog > button {
        margin: auto 6px 6px auto;
        display: block;
      }

      #app {
        height: 100dvh;

        /* grid container settings */
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        grid-template-areas:
          "header"
          "main"
          "footer";
      }

      #app > header {
        grid-area: header;
      }

      #app > main {
        overflow: auto;
        grid-area: main;
        padding: 0 5px 10px 5px;
      }

      #app > footer {
        grid-area: footer;
      }

      footer {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.3rem;
        grid-auto-rows: auto;
        padding-bottom: 1rem;
      }

      footer > button {
        padding-right: 0.1rem;
        padding-left: 0.1rem;
      }

      #unit-btn {
        all: unset;
        position: absolute;
        bottom: 7.3rem;
        right: 0.8rem;
      }
    </style>

    <script src="/keep-screen-on.js" defer=""></script>

    <script>
      navigator.serviceWorker.register("/sw.js");

      /** Converts numeric degrees to radians */
      if (typeof Number.prototype.toRad === "undefined") {
        Number.prototype.toRad = function () {
          return (this * Math.PI) / 180;
        };
      }

      /** Converts string to number */
      if (typeof String.prototype.toNumber === "undefined") {
        String.prototype.toNumber = function () {
          const num = Number(this);
          return Number.isNaN(num) ? null : num;
        };
      }

      const status = document.querySelector("#status");
      const accuracy = document.querySelector("#accuracy");
      const distance = document.querySelector("#distance");
      const state = {
        init() {
          const lat = sessionStorage.getItem("tee-latitude");
          const long = sessionStorage.getItem("tee-longitude");

          this.update({
            unit: localStorage.getItem("unit") ?? "meter",
            tee: {
              latitude: lat?.toNumber() ?? undefined,
              longitude: long?.toNumber() ?? undefined,
            },
            throws: JSON.parse(sessionStorage.getItem("throws")) ?? [],
          });
        },
        get() {
          return { ...this._state };
        },
        update(changes) {
          this._updateNestedObject(this._state, changes);

          sessionStorage.setItem("throws", JSON.stringify(this._state.throws));
          sessionStorage.setItem("tee-latitude", this._state.tee.latitude);
          sessionStorage.setItem("tee-longitude", this._state.tee.longitude);

          if (changes.unit === "feet" || changes.unit === "meter") {
            localStorage.setItem("unit", changes.unit);
          }

          this._getPaths(changes).forEach(path => {
            for (const pattern in this._observers) {
              if (this._matchPath(pattern, path)) {
                this._observers[pattern].forEach(listener => {
                  listener(this.get());
                });
              }
            }
          });
        },
        reset() {
          this.update({
            throws: [],
            tee: {
              latitude: undefined,
              longitude: undefined,
            },
          });
        },
        _updateNestedObject(target, updates) {
          for (const key in updates) {
            if (
              typeof updates[key] === "object" &&
              updates[key] !== null &&
              !Array.isArray(updates[key])
            ) {
              if (typeof target[key] !== "object" || target[key] === null) {
                target[key] = {};
              }
              this._updateNestedObject(target[key], updates[key]);
            } else {
              target[key] = updates[key];
            }
          }
        },
        _getPaths(obj, prefix = "") {
          const paths = [];

          for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
              const path = prefix ? `${prefix}.${key}` : key;
              if (
                typeof obj[key] === "object" &&
                obj[key] !== null &&
                !Array.isArray(obj[key])
              ) {
                paths.push(...this._getPaths(obj[key], path));
              } else {
                paths.push(path);
              }
            }
          }

          return paths;
        },
        _matchPath(pattern, path) {
          const regex = new RegExp(
            "^" + pattern.replace("\.", "\\.").replace(/\*/g, ".*") + "$"
          );
          return regex.test(path);
        },
        _observers: {
          "current.accuracy": [updateAccuracy],
          "current.*": [updateDistance],
          "tee.*": [updateDistance, updateThrows],
          unit: [updateAccuracy, updateDistance, updateThrows],
          throws: [updateThrows],
        },
        _state: {
          unit: undefined,
          throws: [],
          tee: {
            latitude: undefined,
            longitude: undefined,
          },
          current: {
            accuracy: undefined,
            latitude: undefined,
            longitude: undefined,
          },
        },
      };

      /**
       * Convert the distance from cm to feet or meter and add unit.
       * @param  {Number}  distance Distance in centimeters
       * @return {string}  Distance in the preferred unit with the unit attached
       */
      function getDistanceWithPreferredUnit(distance) {
        if (state.get().unit === "feet") {
          return `${Math.round(distance * 0.0328084)} feet`;
        } else {
          return `${Math.round(distance / 100)}m`;
        }
      }

      /**
       * Calculate distance using the haversine formula.
       * From https://stackoverflow.com/q/18883601
       * @param  {Object}  from The starting position
       * @param  {Object}  to   The ending position
       * @return {Number}  Distance in centimeters
       */
      function getDistanceBetween(from, to) {
        const R = 6371;
        const dLat = (to.latitude - from.latitude).toRad();
        const dLong = (to.longitude - from.longitude).toRad();

        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(from.latitude.toRad()) *
            Math.cos(to.latitude.toRad()) *
            Math.sin(dLong / 2) *
            Math.sin(dLong / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const distance = R * c * 1000 * 100;
        return Math.round(distance);
      }

      /**
       * Update distance in the DOM
       * @param  {Object} state
       */
      function updateDistance(state) {
        if (
          !state.tee.latitude ||
          !state.tee.longitude ||
          !state.current.latitude ||
          !state.current.longitude
        ) {
          distance.textContent = "–";
          return;
        }
        const diff = getDistanceBetween(
          {
            latitude: state.tee.latitude,
            longitude: state.tee.longitude,
          },
          {
            latitude: state.current.latitude,
            longitude: state.current.longitude,
          }
        );

        distance.textContent = getDistanceWithPreferredUnit(diff);
      }

      /**
       * Update accuracy in the DOM
       * @param  {Object} state
       */
      function updateAccuracy(state) {
        if (typeof state.current.accuracy !== "number") {
          return;
        }

        const plaintext = (() => {
          switch (true) {
            case state.current.accuracy < 500:
              return "good";
            case state.current.accuracy < 1000:
              return "decent";
            default:
              return "bad";
          }
        })();

        status.textContent = `Accuracy is ${plaintext} at ±${getDistanceWithPreferredUnit(
          state.current.accuracy
        )}`;
      }

      /**
       * Update throws in the DOM
       * @param  {Object} state
       */
      function updateThrows(state) {
        const div = document.querySelector("#throws-statistics");

        if (!state.throws || state.throws?.length === 0) {
          div.textContent = "";
          return;
        }

        if (state.tee.latitude && state.tee.longitude) {
          const distances = state.throws.map(t =>
            getDistanceBetween(
              {
                latitude: state.tee.latitude,
                longitude: state.tee.longitude,
              },
              {
                latitude: t.latitude,
                longitude: t.longitude,
              }
            )
          );

          const average =
            distances.reduce(
              (accumulator, currentValue) => accumulator + currentValue,
              0
            ) / distances.length;

          const ol = document.createElement("ol");

          distances
            .map(d => getDistanceWithPreferredUnit(d))
            .map(s => {
              const li = document.createElement("li");
              li.textContent = s;
              return li;
            })
            .forEach(t => ol.appendChild(t));

          const p = document.createElement("p");
          p.textContent = `Average: ${getDistanceWithPreferredUnit(average)}`;

          div.innerHTML = `<h2>Throws</h2>`;

          div.appendChild(ol);
          div.appendChild(p);
        } else {
          div.textContent = "";
          const p = document.createElement("p");
          p.textContent = `Set starting position to calculate distance for ${state.throws.length} throws.`;

          div.appendChild(p);
        }
      }

      /**
       * Update the current position in the state object
       * @param  {Object}  position The current position
       */
      function updatePosition(position) {
        state.update({
          current: {
            accuracy: position.coords.accuracy * 100, // Save accuracy in cm to simplify conversions later
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
          },
        });
      }

      /**
       * Error when retrieve the position
       */
      function error() {
        status.textContent = "Unable to retrieve your location";
      }

      /**
       * Set the starting point to calculate distance from
       */
      function setStartPosition() {
        const currentState = state.get();
        if (currentState.current.latitude && currentState.current.longitude) {
          state.update({
            tee: {
              latitude: currentState.current.latitude,
              longitude: currentState.current.longitude,
            },
          });
        }
      }

      /**
       * Save the current position as a throw
       */
      function saveThrow() {
        const currentState = state.get();
        const _throw = {
          latitude: currentState.current.latitude,
          longitude: currentState.current.longitude,
        };
        if (
          currentState.current.latitude &&
          currentState.current.longitude &&
          !currentState.throws.some(
            x =>
              x.latitude === _throw.latitude && x.longitude === _throw.longitude
          )
        ) {
          state.update({
            throws:
              currentState.throws instanceof Array
                ? [...currentState.throws, _throw]
                : [_throw],
          });
        }
      }

      /**
       * Reset all throws
       */
      function clearThrows() {
        state.update({
          throws: [],
        });
      }

      /**
       * Add "disabled"-attribute to the element for 500ms.
       */
      function disableBriefly(e) {
        const element = e.srcElement;
        element.setAttribute("disabled", true);
        setTimeout(() => {
          element.removeAttribute("disabled");
        }, 500);
      }

      function toggleUnit(e) {
        const btn = document.querySelector("#unit-btn");

        if (state.get().unit === "feet") {
          state.update({ unit: "meter" });
          btn.textContent = "use feet";
        } else {
          state.update({ unit: "feet" });
          btn.textContent = "use meters";
        }
      }

      if (!navigator.geolocation) {
        status.textContent = "Geolocation is not supported by your browser.";
      } else {
        status.textContent = "Locating…";
        const options = {
          enableHighAccuracy: true,
        };
        navigator.geolocation.watchPosition(updatePosition, error, options);
      }

      state.init();

      document
        .querySelectorAll("button:not(#unit-btn)")
        .forEach(button => button.addEventListener("click", disableBriefly));

      document
        .querySelector("#start-btn")
        .addEventListener("click", setStartPosition);

      document.querySelector("#unit-btn").textContent =
        state.get().unit === "feet" ? "use meters" : "use feet";
      document.querySelector("#unit-btn").addEventListener("click", toggleUnit);

      document
        .querySelector("#clear-throws-btn")
        .addEventListener("click", clearThrows);

      document
        .querySelector("#reset-all-btn")
        .addEventListener("click", e => state.reset());

      document.querySelector("#save-btn").addEventListener("click", saveThrow);

      const aboutDialog = document.querySelector("#about-dialog");

      document
        .querySelector("#about-dialog-trigger")
        .addEventListener("click", () => {
          aboutDialog.showModal();
        });

      document
        .querySelector("#about-dialog button")
        .addEventListener("click", () => {
          aboutDialog.close();
        });
    </script>
  </body>
</html>
